# -*- coding: utf-8 -*-
"""
/***************************************************************************
 LitterMapDialog
                                 A QGIS plugin
 Get data obtained from UAV images processed by AI
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2022-06-15
        git sha              : $Format:%H$
        copyright            : (C) 2022 by Pavel Pereverzev
        email                : pasha004@yandex.ru
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
import boto3
from botocore.exceptions import NoCredentialsError, ClientError
import logging
from datetime import datetime

from qgis.PyQt import uic
from qgis.PyQt import QtWidgets
from qgis._core import *
from qgis.utils import iface

import csv
import json
import math
import os
from osgeo import gdal, osr
import sys

from .exiftool_custom import ExifToolHelper

# from skimage.util.shape import view_as_windows
# import numpy as np
# from scipy import signal
import requests
import ast

from PyQt5 import QtCore
from PyQt5.QtGui import *
from PyQt5.QtCore import *

from PyQt5.QtWidgets import QApplication, QWidget, QComboBox, QDateEdit, QLineEdit, QGridLayout, QLabel, QPushButton, \
    QMessageBox, QFileDialog, QListView, QProgressBar, QTreeWidget, QTreeWidgetItem, QAction, QCheckBox, QTextEdit

from qgis._core import *
from qgis.utils import iface
from qgis.core import QgsCoordinateReferenceSystem, QgsCoordinateTransform, QgsPoint, QgsFeature, QgsGeometry, \
    QgsVectorLayer, QgsPointXY, QgsRasterLayer
from qgis.PyQt import uic

crs_metric = QgsCoordinateReferenceSystem(3857)
crs_degrees = QgsCoordinateReferenceSystem(4326)
tr_to_meters = QgsCoordinateTransform(crs_degrees, crs_metric, QgsProject.instance())
tr_to_degrees = QgsCoordinateTransform(crs_metric, crs_degrees, QgsProject.instance())

current_folder = os.path.dirname(os.path.realpath(__file__))
classes_style = os.path.join(current_folder, r"classes_style.qml")
heatmap_style = os.path.join(current_folder, r"heatmap_style.qml")
#exiftool_exe = os.path.join(current_folder, r"tools\exiftool.exe")
exiftool_exe = r"C:\Users\Administrator\Desktop\garbage-detection-dev\qgis-plugin\litter_map\tools\exiftool.exe"

# Настройка логирования
def setup_logging():
    # Создаем директорию для логов в папке плагина, если её нет
    log_dir = os.path.join(os.path.dirname(os.path.realpath(__file__)), 'logs')
    if not os.path.exists(log_dir):
        os.makedirs(log_dir)
    
    # Создаем имя файла с текущей датой
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    log_file_plugin = os.path.join(log_dir, f'litter_map_{timestamp}.log')
    log_file_desktop = os.path.join(os.path.expanduser("~/Desktop"), f'litter_map_{timestamp}.log')
    
    # Настраиваем логирование
    logging.basicConfig(
        level=logging.DEBUG,
        format='%(asctime)s - %(levelname)s - %(message)s',
        handlers=[
            logging.FileHandler(log_file_plugin, encoding='utf-8'),
            logging.FileHandler(log_file_desktop, encoding='utf-8'),
            logging.StreamHandler()  # Также выводим в консоль
        ]
    )
    return log_file_plugin, log_file_desktop

# Инициализируем логирование при импорте модуля
log_file_plugin, log_file_desktop = setup_logging()
logging.info(f"Starting LitterMap plugin")
logging.info(f"Python version: {sys.version}")
logging.info(f"QGIS version: {QgsApplication.QGIS_VERSION}")
logging.info(f"Log files created at:")
logging.info(f"- Plugin directory: {log_file_plugin}")
logging.info(f"- Desktop: {log_file_desktop}")

def extract_polygon(coors, coef_data):
    A, B, D, E, C, F = coef_data
    points = []
    for coor in coors:
        y, x = coor
        x_cor = A * x + B * y + C
        y_cor = D * x + E * y + F
        points.append(QgsPointXY(x_cor, y_cor))
    box_polygon = QgsGeometry.fromPolygonXY([points])
    centroid = box_polygon.centroid()
    return centroid.asPoint().x(), centroid.asPoint().y()


def meter2Degree(latitude, x_length, y_length):
    # convert meter values to degrees
    x_length = x_length / (111320 * math.cos(math.radians(latitude)))
    y_length = y_length / 110540
    return x_length, y_length


def angle_bearing(x_one, y_one, x_two, y_two):
    # calculate azimuth angle
    angle = math.degrees(math.atan2(y_two - y_one, x_two - x_one))
    return (90 - angle) % 360


def distance_pp(pnt_one, pnt_two):
    # distance between two points
    x_start, y_start = pnt_one
    x_end, y_end = pnt_two
    return math.sqrt((x_end - x_start) ** 2 + (y_end - y_start) ** 2)


def delete_tech_layers(list_layers_to_delete):
    # delete layers by names
    for name in list_layers_to_delete:
        if len(QgsProject.instance().mapLayersByName(name)) > 0:
            ds = QgsProject.instance().mapLayersByName(name)[0]
            QgsProject.instance().removeMapLayer(ds.id())
    return


def add_tech_layer(name, type_geometry):
    # add temporary layer
    delete_tech_layers([name])
    iface.mainWindow().blockSignals(True)
    tech_layer = QgsVectorLayer(type_geometry, name, "memory")
    tech_layer.dataProvider().addAttributes([QgsField("type", QVariant.String)])
    tech_layer.dataProvider().addAttributes([QgsField("area", QVariant.Double)])
    tech_layer.setCrs(crs_degrees)
    tech_layer.updateFields()
    iface.mainWindow().blockSignals(False)
    return tech_layer


def img_frame(A, B, D, E, C, F, iw, ih):
    x_one = C
    y_one = F
    x_two = A * iw + B * 0 + x_one
    y_two = D * iw + E * 0 + y_one
    x_three = A * iw + B * ih + x_one
    y_three = D * iw + E * ih + y_one
    x_four = A * 0 + B * ih + x_one
    y_four = D * 0 + E * ih + y_one
    coors = [
        QgsPointXY(x_one, y_one),
        QgsPointXY(x_two, y_two),
        QgsPointXY(x_three, y_three),
        QgsPointXY(x_four, y_four),
        QgsPointXY(x_one, y_one)
    ]
    polygon_geom = QgsGeometry().fromPolygonXY([coors])
    return polygon_geom


def get_corner_points(center_lon, center_lat, altitude, dir_angle, pitch, aspect, sensor_width, focal_length):
    # get corner points of image
    # calculations based on photogrammetry tutorial
    ratXh = sensor_width / focal_length / 2  # ratio of sensor half-width to focal length (at image centre)
    ratYh = aspect * ratXh  # ditto for sensor half-height
    ccf = 1.5 * math.sqrt(1 + (
            ratYh ** 2))  # "corner correction factor" due to sensor crop and fisheye correction. For 0.75 aspect this becomes 1.13, but needs to be calibrated for each camera!
    phiXh, phiYh = math.atan(ratXh), math.atan(
        ratYh)  # 1/2-FOV angle in X,Y directions at image centre. Will be in radians.

    # ground distance of camera ground projection to image; centre, front, back
    Kc = altitude / math.tan(-1 * pitch)
    Kf = altitude / math.tan(-1 * pitch + phiYh)
    Kb = altitude / math.tan(-1 * pitch + phiYh * -1)

    # full distance, hypotenuse of ground distance and altitude triangle
    Rc = math.sqrt(altitude ** 2 + Kc ** 2)
    Rf = math.sqrt(altitude ** 2 + Kf ** 2)
    Rb = math.sqrt(altitude ** 2 + Kb ** 2)

    # 1/2 width of frame in ground coordinates, at centre, front, back; includes ccf fudge factor in corners
    Wch = Rc * ratXh / 1
    Wfh = Rf * ratXh / ccf
    Wbh = Rb * ratXh / ccf

    Centre_W, Centre_K = 0, Kc
    BR_K = BL_K = Kf
    TR_K = TL_K = Kb
    BL_W = BR_W = Wfh
    BR_W = BR_W * -1
    TL_W = TR_W = Wbh
    TR_W = TR_W * -1

    Centre_x = center_lon + (Centre_W) * math.cos(dir_angle) + (Centre_K) * math.sin(dir_angle)
    BR_x = center_lon + (BR_W) * math.cos(dir_angle) + (BR_K) * math.sin(dir_angle)
    BL_x = center_lon + (BL_W) * math.cos(dir_angle) + (BL_K) * math.sin(dir_angle)
    TR_x = center_lon + (TR_W) * math.cos(dir_angle) + (TR_K) * math.sin(dir_angle)
    TL_x = center_lon + (TL_W) * math.cos(dir_angle) + (TL_K) * math.sin(dir_angle)

    Centre_y = center_lat - (Centre_W) * math.sin(dir_angle) + (Centre_K) * math.cos(dir_angle)
    BR_y = center_lat - (BR_W) * math.sin(dir_angle) + (BR_K) * math.cos(dir_angle)
    BL_y = center_lat - (BL_W) * math.sin(dir_angle) + (BL_K) * math.cos(dir_angle)
    TR_y = center_lat - (TR_W) * math.sin(dir_angle) + (TR_K) * math.cos(dir_angle)
    TL_y = center_lat - (TL_W) * math.sin(dir_angle) + (TL_K) * math.cos(dir_angle)

    pntTL = QgsGeometry().fromPointXY(QgsPointXY(TL_x, TL_y))
    pntTR = QgsGeometry().fromPointXY(QgsPointXY(TR_x, TR_y))
    pntBL = QgsGeometry().fromPointXY(QgsPointXY(BL_x, BL_y))
    pntBR = QgsGeometry().fromPointXY(QgsPointXY(BR_x, BR_y))

    pntTL.transform(tr_to_degrees)
    pntTR.transform(tr_to_degrees)
    pntBL.transform(tr_to_degrees)
    pntBR.transform(tr_to_degrees)

    return [pntTL, pntTR, pntBL, pntBR]


def georeference_img(file_in, processed_path, add_points, add_raster):
    try:
        logging.info(f"Processing image: {file_in}")
        file_jgw = os.path.join(os.path.dirname(processed_path), os.path.basename(processed_path).replace('JPG', 'jgw'))

        if not os.path.exists(exiftool_exe):
            logging.error(f"ExifTool not found at: {exiftool_exe}")
            return None

        with ExifToolHelper(executable=exiftool_exe) as et:
            metadata = et.get_metadata(file_in)
            if not metadata:
                logging.error(f"No EXIF metadata found in {file_in}")
                return None
            
            d = metadata[0]
            logging.debug(f"EXIF data: {d}")
            
            # List of required EXIF tags
            required_tags = {
                'Composite:GPSLatitude': 'GPS координаты (широта)',
                'Composite:GPSLongitude': 'GPS координаты (долгота)',
                'XMP:RelativeAltitude': 'Относительная высота',
                'XMP:GimbalPitchDegree': 'Угол наклона камеры',
                'XMP:FlightYawDegree': 'Курс дрона',
                'EXIF:FocalLength': 'Фокусное расстояние',
                'EXIF:ExifImageWidth': 'Ширина изображения',
                'EXIF:ExifImageHeight': 'Высота изображения',
                'Composite:FOV': 'Поле зрения камеры'
            }
            
            # Check for missing tags
            missing_tags = []
            for tag, description in required_tags.items():
                if tag not in d:
                    missing_tags.append(f"{description} ({tag})")
            
            if missing_tags:
                logging.error(f"Missing EXIF tags in {file_in}:")
                for tag in missing_tags:
                    logging.error(f"- {tag}")
                return None

            try:
                # get image data
                lat = float(d['Composite:GPSLatitude'])
                lon = float(d['Composite:GPSLongitude'])
                altitude_value = float(d['XMP:RelativeAltitude'])
                pitch_value = float(d['XMP:GimbalPitchDegree']) / 180 * math.pi
                dir_spin_value = (90 + float(d['XMP:FlightYawDegree'])) / 180 * math.pi
                dir_init_value = float(d['XMP:FlightYawDegree'])
                focal_length_value = float(d['EXIF:FocalLength']) / 1000
                img_width = int(d['EXIF:ExifImageWidth'])
                img_height = int(d['EXIF:ExifImageHeight'])

                logging.debug(f"Image dimensions: {img_width}x{img_height}")
                logging.debug(f"GPS coordinates: {lat}, {lon}")
                logging.debug(f"Altitude: {altitude_value}")
                logging.debug(f"Pitch: {pitch_value}")
                logging.debug(f"Direction: {dir_init_value}")

                # calculate auxiliary data
                sensor_width = 2 * (focal_length_value * math.tan((0.5 * float(d['Composite:FOV'])) / 57.296))
                sensor_height = img_height / img_width * sensor_width
                sensor_width_deg, sensor_height_deg = meter2Degree(lat, sensor_width, sensor_height)
                aspect = img_width / img_height
                scale_factor = altitude_value / focal_length_value
                sensor_pixel_width_degrees = sensor_width_deg / img_width
                sensor_pixel_length_degrees = sensor_height_deg / img_height
                img_hwidth_degrees = (sensor_width_deg * scale_factor) / 2
                img_hlength_degrees = (sensor_height_deg * scale_factor) / 2
                ground_pixel_width = sensor_pixel_width_degrees * scale_factor
                ground_pixel_length = sensor_pixel_length_degrees * scale_factor

                logging.debug(f"Calculated parameters:")
                logging.debug(f"- Sensor width: {sensor_width}")
                logging.debug(f"- Sensor height: {sensor_height}")
                logging.debug(f"- Scale factor: {scale_factor}")
                logging.debug(f"- Ground pixel width: {ground_pixel_width}")
                logging.debug(f"- Ground pixel length: {ground_pixel_length}")

                # points calculations
                pnt_orig = QgsGeometry().fromPointXY(QgsPointXY(lon, lat))
                pnt = QgsGeometry().fromPointXY(QgsPointXY(lon, lat))
                pnt.transform(tr_to_meters)
                lon_m, lat_m = pnt.asPoint().x(), pnt.asPoint().y()

                logging.debug(f"Transformed coordinates: {lon_m}, {lat_m}")

                # get corner points
                pntTL, pntTR, pntBL, pntBR = get_corner_points(
                    center_lon=lon_m,
                    center_lat=lat_m,
                    altitude=altitude_value,
                    dir_angle=dir_spin_value,
                    pitch=pitch_value,
                    aspect=aspect,
                    sensor_width=sensor_width,
                    focal_length=focal_length_value
                )

                # get corners' x and y
                x_tl, y_tl = pntTL.asPoint().x(), pntTL.asPoint().y()
                x_tr, y_tr = pntTR.asPoint().x(), pntTR.asPoint().y()
                x_bl, y_bl = pntBL.asPoint().x(), pntBL.asPoint().y()
                x_br, y_br = pntBR.asPoint().x(), pntBR.asPoint().y()

                logging.debug(f"Corner points:")
                logging.debug(f"TL: ({x_tl}, {y_tl})")
                logging.debug(f"TR: ({x_tr}, {y_tr})")
                logging.debug(f"BL: ({x_bl}, {y_bl})")
                logging.debug(f"BR: ({x_br}, {y_br})")

                # calculate ABDE coefficients
                A = math.cos(math.radians(dir_init_value)) * ground_pixel_width
                B = -(math.sin(math.radians(dir_init_value)) * ground_pixel_length)
                D = -(math.sin(math.radians(dir_init_value)) * ground_pixel_width)
                E = -(math.cos(math.radians(dir_init_value)) * ground_pixel_length)

                C, F = x_br, y_br

                logging.debug(f"Final coefficients:")
                logging.debug(f"A: {A}")
                logging.debug(f"B: {B}")
                logging.debug(f"D: {D}")
                logging.debug(f"E: {E}")
                logging.debug(f"C: {C}")
                logging.debug(f"F: {F}")

                # write world file
                with open(file_jgw, 'w') as f:
                    f.write(f"{A:1.10f}\n")  # A
                    f.write(f"{B:1.10f}\n")  # D
                    f.write(f"{D:1.10f}\n")  #
                    f.write(f"{E:1.10f}\n")
                    f.write(f"{x_br}\n")
                    f.write(f"{y_br}")

                if add_raster:
                    r_layer = QgsRasterLayer(processed_path, os.path.basename(processed_path))
                    r_layer.setCrs(crs_degrees)
                    QgsProject.instance().addMapLayer(r_layer)
                    provider = r_layer.dataProvider()
                    provider.setNoDataValue(1, 0)  # remove black value
                    r_layer.triggerRepaint()
                    l_id = QgsProject.instance().layerTreeRoot().findLayer(r_layer.id())
                    l_id.setExpanded(False)

                if add_points:
                    new_layer = add_tech_layer("PNTS", 'Point')
                    for g in [pnt_orig, pntTL, pntTR, pntBL, pntBR]:
                        r_feature = QgsFeature()
                        r_feature.setFields(new_layer.fields())
                        r_feature.setGeometry(g)
                        new_layer.dataProvider().addFeatures([r_feature])
                    QgsProject.instance().addMapLayer(new_layer)

                logging.info(f"Successfully processed image: {file_in}")
                return A, B, D, E, C, F, img_width, img_height

            except ValueError as e:
                logging.error(f"Invalid EXIF data values in {file_in}: {str(e)}")
                return None

    except Exception as e:
        logging.error(f"Error processing image {file_in}: {str(e)}", exc_info=True)
        return None


class LitterMapDialog(QWidget):
    def __init__(self, parent=None):
        # set interface and variables
        super().__init__(parent)

        # variables
        self.attempt = 1
        self.current_xy = []
        self.point_tool = None
        self.dct_img = {}
        self.stat_data = []

        # mainframe settings
        # self.setWindowFlags(self.windowFlags() | QtCore.Qt.WindowStaysOnTopHint)
        self.setWindowTitle('LitterMap')
        self.setGeometry(800, 650, 350, 0)

        self.btn_load_images = QPushButton("Загрузить изображения")

        self.txt_area = QTextEdit(self)
        self.txt_area.setReadOnly(True)
        # self.btn_save_stat = QPushButton("Сохранить статистику")
        self.prog_bar = QProgressBar(self)

        self.grid_layout = QGridLayout(self)
        self.grid_layout.setSpacing(10)
        self.setLayout(self.grid_layout)

        self.grid_layout.addWidget(self.btn_load_images, 0, 1, 1, 3)
        self.grid_layout.addWidget(self.txt_area, 1, 1, 1, 3)
        # self.grid_layout.addWidget(self.btn_save_stat, 2, 1, 1, 3)
        self.grid_layout.addWidget(self.prog_bar, 2, 1, 1, 3)

        self.btn_load_images.clicked.connect(self.load_images)
        # self.btn_save_stat.clicked.connect(self.save_stat)
        # self.btn_save_stat.setDisabled(True)

        self.show()

    def save_stat(self):
        out_file = QFileDialog.getSaveFileName(None, "Сохранить статистику", "", "CSV (*.csv)")
        if out_file[0]:
            with open(out_file[0], mode='w', encoding='cp1251', newline='') as stat_file:
                stat_writer = csv.writer(stat_file, delimiter=';')
                for row in self.stat_data:
                    row_corrected = [row[0], '="{}"'.format(row[1]), '="{}"'.format(row[2])]
                    stat_writer.writerow(row_corrected)
            self.warning_message('Статистика записана в файл {}'.format(out_file[0]))

    def warning_message(self, err_text):
        # message box

        msg = QMessageBox()
        msg.warning(self, "Уведомление", err_text)
        return

    def process_image(self, image_path, processed_dir_path):
        url = "https://node-api.datasphere.yandexcloud.net/process"
        headers = {
            "x-node-alias": "datasphere.user.segmentation-backend",
            "Authorization": "Api-Key AQVN1vLuEmspghqfLIBxf2nmNDzctez-kjrrxKdx",
            "x-folder-id": "b1gbm9skjpv4gt0r8dmi",
        }
        response = requests.post(url, headers=headers, files={"image": open(image_path, 'rb')})
        processed_path = ""
        cl_coefs = {}
        if response.status_code == 400:
            print(response.text)
        else:
            base_name = os.path.basename(image_path)
            processed_path = os.path.join(processed_dir_path, base_name)
            save_file = open(processed_path, "wb")
            save_file.write(response.content)
            save_file.close()

            # Upload to Yandex Storage
            access_key = 'YCAJEx_tO4BLa7mIZG8FJB00p'
            secret_key = 'YCOIINmv-D_Nb6U53VsoBJEZ87K4eOH4ZU7mMxQm'
            bucket_name = 'yngcook'
            endpoint_url = 'https://storage.yandexcloud.net'
            object_name = f'processed/{base_name}'  # Store in processed/ subfolder

            session = boto3.session.Session()
            s3 = session.client(
                service_name='s3',
                endpoint_url=endpoint_url,
                aws_access_key_id=access_key,
                aws_secret_access_key=secret_key,
                region_name='ru-central1'
            )

            try:
                s3.upload_file(
                    Filename=processed_path,
                    Bucket=bucket_name,
                    Key=object_name,
                    ExtraArgs={'ACL': 'public-read'}
                )
                print(f"Successfully uploaded {object_name} to Yandex Storage")
            except Exception as e:
                print(f"Error uploading to Yandex Storage: {str(e)}")

            cl_coefs_str = response.cookies.get("cl_coefs").replace("\\054", ",")[1:-1]
            cl_coefs = ast.literal_eval(cl_coefs_str)
        return processed_path, cl_coefs

    def load_images(self):
        images = QFileDialog.getOpenFileNames(self, 'Загрузить изображения', None, "Image files (*.jpg)")[0]
        if not images:
            return
        step = 100. / len(images)
        step_count = 0
        new_layer_polygon = add_tech_layer("Frames", 'Multipolygon')

        stat_litter_count = 0
        stat_litter_area = 0
        stat_litter_volume = 0
        stat_litter_mass = 0

        # Create CSV file for garbage points
        dirpath = os.path.dirname(os.path.abspath(images[0]))
        csv_path = os.path.join(dirpath, "garbage_points.csv")
        with open(csv_path, mode='w', encoding='utf-8', newline='') as csv_file:
            csv_writer = csv.writer(csv_file, delimiter=';')
            csv_writer.writerow(['Тип мусора', 'Широта', 'Долгота', 'Площадь (кв.м)', 'Объем (куб.м)', 'Масса (кг)'])

        cl_to_name = {
            1: "железо",
            2: "рыболовные снасти",
            3: "пластик",
            4: "дерево",
            5: "бетон",
            6: "резина"
        }
        name_to_cl = {
            y: x for x, y in cl_to_name.items()
        }
        stat_litter_classes = {}
        for _, name in cl_to_name.items():
            stat_litter_classes[name] = {
                'cnt': 0,
                'area': 0.0,
                'volume': 0.0,
                'mass': 0.0
            }

        all_frame = None
        frame_intersection = None

        pic_coors = add_tech_layer('NN_points', 'Point')
        # pic_coors_heatmap = add_tech_layer('NN_points_heatmap', 'Point')

        dirpath = os.path.dirname(os.path.abspath(images[0]))
        processed_dir = dirpath + "/processed"
        try:
            os.makedirs(processed_dir)
        except:
            pass

        for file_in in images:
            processed_path, cl_to_coefs = self.process_image(file_in, processed_dir_path=processed_dir)

            A, B, D, E, C, F, iw, ih = georeference_img(file_in, processed_path, True, True)
            polygon_coors = img_frame(A, B, D, E, C, F, iw, ih)

            r_feature = QgsFeature()
            r_feature.setFields(new_layer_polygon.fields())
            r_feature.setGeometry(polygon_coors)
            new_layer_polygon.dataProvider().addFeatures([r_feature])

            # self.dct_img[f_name.replace('.JPG', '')] = [A, B, D, E, C, F, iw, ih]
            polygon_coors_m = img_frame(A, B, D, E, C, F, iw, ih)
            polygon_coors_m.transform(tr_to_meters)

            # if not x_length:
            #     flat_polygon = img_frame(A, 0, 0, E, C, F, 1, 1)
            #     flat_polygon.transform(tr_to_meters)
            #     x_length = round(flat_polygon.boundingBox().width(), 2) * 100
            #     y_length = round(flat_polygon.boundingBox().height(), 2) * 100

            area_polygon = polygon_coors_m.area()

            if all_frame:
                frame_intersection = all_frame.intersection(polygon_coors)

            for cl, type_pnt in cl_to_name.items():
                points = cl_to_coefs[cl]

                for point in points:
                    y, x, area, volume_coef, mass_coef = point
                    if area <= 0:
                        continue
                    # может быть нужно поменять x и у местами
                    x_cor = A * x + B * y + C
                    y_cor = D * x + E * y + F

                    # centroid = polygon_coors.centroid()
                    # x_cor, y_cor = centroid.asPoint().x(), centroid.asPoint().y()

                    area = round(area_polygon * area / (iw * ih), 3)
                    pnt = QgsGeometry().fromPointXY(QgsPointXY(x_cor, y_cor))
                    if frame_intersection:
                        if pnt.intersects(all_frame):
                            continue
                    r_feature = QgsFeature()
                    r_feature.setFields(pic_coors.fields())
                    r_feature["type"] = type_pnt
                    r_feature["area"] = area
                    stat_litter_area += area
                    stat_litter_classes[type_pnt]['area'] += area

                    volume = area * volume_coef
                    mass = area * mass_coef

                    stat_litter_classes[type_pnt]['cnt'] += 1
                    stat_litter_classes[type_pnt]['volume'] += volume
                    stat_litter_classes[type_pnt]['mass'] += mass

                    stat_litter_volume += volume
                    stat_litter_mass += mass
                    stat_litter_count += 1

                    r_feature.setGeometry(pnt)
                    pic_coors.dataProvider().addFeatures([r_feature])

                    # Save point data to CSV
                    with open(csv_path, mode='a', encoding='utf-8', newline='') as csv_file:
                        csv_writer = csv.writer(csv_file, delimiter=';')
                        csv_writer.writerow([
                            type_pnt,
                            f"{y_cor:.6f}",
                            f"{x_cor:.6f}",
                            f"{area:.3f}",
                            f"{volume:.3f}",
                            f"{mass:.3f}"
                        ])

                    # pic_coors_heatmap.dataProvider().addFeatures([r_feature])
            if not all_frame:
                all_frame = polygon_coors
            else:
                all_frame = all_frame.combine(polygon_coors)

            step_count += step
            self.prog_bar.setValue(int(step_count))
            QtCore.QCoreApplication.processEvents()

        for t in stat_litter_classes:
            stat_litter_classes[t]['area'] = round(stat_litter_classes[t]['area'], 2)
            stat_litter_classes[t]['volume'] = round(stat_litter_classes[t]['volume'], 2)
            stat_litter_classes[t]['mass'] = round(stat_litter_classes[t]['mass'], 2)

        stat_litter_area = round(stat_litter_area, 2)
        stat_litter_volume = round(stat_litter_volume, 2)
        stat_litter_mass = round(stat_litter_mass, 2)

        centroid_polygon = all_frame.centroid().asPoint()
        c_x, c_y = round(centroid_polygon.x(), 5), round(centroid_polygon.y(), 5)
        all_frame.transform(tr_to_meters)

        stat_msg = ""

        for cl, name in cl_to_name.items():
            if name in stat_litter_classes:
                stat_msg += f"{name}: количество - {stat_litter_classes[name]['cnt']},  площадь - {stat_litter_classes[name]['area']} кв.м., объём - {stat_litter_classes[name]['volume']} куб.м., масса - {stat_litter_classes[name]['mass']} кг\n"

        stat_msg += f"fСуммарно: количество: {stat_litter_count}, площадь: {stat_litter_area}, объём: {stat_litter_volume}, масса: {stat_litter_mass}\n"
        stat_msg += f"Центроид участка - ({c_x}, {c_y})\n"
        self.txt_area.setPlainText(stat_msg)

        # Upload CSV file to Yandex Storage
        access_key = 'YCAJEx_tO4BLa7mIZG8FJB00p'
        secret_key = 'YCOIINmv-D_Nb6U53VsoBJEZ87K4eOH4ZU7mMxQm'
        bucket_name = 'yngcook'
        endpoint_url = 'https://storage.yandexcloud.net'
        csv_object_name = f'data/garbage_points.csv'  # Store in data/ subfolder

        session = boto3.session.Session()
        s3 = session.client(
            service_name='s3',
            endpoint_url=endpoint_url,
            aws_access_key_id=access_key,
            aws_secret_access_key=secret_key,
            region_name='ru-central1'
        )

        try:
            s3.upload_file(
                Filename=csv_path,
                Bucket=bucket_name,
                Key=csv_object_name,
                ExtraArgs={'ACL': 'public-read'}
            )
            print(f"Successfully uploaded {csv_object_name} to Yandex Storage")
        except Exception as e:
            print(f"Error uploading CSV to Yandex Storage: {str(e)}")

        QgsProject.instance().addMapLayer(pic_coors)
        # QgsProject.instance().addMapLayer(pic_coors_heatmap)
        pic_coors.loadNamedStyle(classes_style)
        # pic_coors_heatmap.loadNamedStyle(heatmap_style)
        # self.btn_save_stat.setDisabled(False)
        self.prog_bar.setValue(0)

# app = LitterMapDialog()
