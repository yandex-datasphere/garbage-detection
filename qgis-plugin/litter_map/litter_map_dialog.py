# -*- coding: utf-8 -*-
"""
/***************************************************************************
 LitterMapDialog
                                 A QGIS plugin
 Get data obtained from UAV images processed by AI
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2022-06-15
        git sha              : $Format:%H$
        copyright            : (C) 2022 by Pavel Pereverzev
        email                : pasha004@yandex.ru
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os

from qgis.PyQt import uic
from qgis.PyQt import QtWidgets
from qgis._core import *
from qgis.utils import iface

import csv
import json
import math
import os
from osgeo import gdal, osr

from .exiftool_custom import ExifToolHelper

# from skimage.util.shape import view_as_windows
# import numpy as np
# from scipy import signal
import requests
import ast

from PyQt5 import QtCore
from PyQt5.QtGui import *
from PyQt5.QtCore import *

from PyQt5.QtWidgets import QApplication, QWidget, QComboBox, QDateEdit, QLineEdit, QGridLayout, QLabel, QPushButton, \
    QMessageBox, QFileDialog, QListView, QProgressBar, QTreeWidget, QTreeWidgetItem, QAction, QCheckBox, QTextEdit

from qgis._core import *
from qgis.utils import iface
from qgis.core import QgsCoordinateReferenceSystem, QgsCoordinateTransform, QgsPoint, QgsFeature, QgsGeometry, \
    QgsVectorLayer, QgsPointXY, QgsRasterLayer
from qgis.PyQt import uic

crs_metric = QgsCoordinateReferenceSystem(3857)
crs_degrees = QgsCoordinateReferenceSystem(4326)
tr_to_meters = QgsCoordinateTransform(crs_degrees, crs_metric, QgsProject.instance())
tr_to_degrees = QgsCoordinateTransform(crs_metric, crs_degrees, QgsProject.instance())

current_folder = os.path.dirname(os.path.realpath(__file__))
classes_style = os.path.join(current_folder, r"classes_style.qml")
heatmap_style = os.path.join(current_folder, r"heatmap_style.qml")
exiftool_exe = os.path.join(current_folder, r"tools\exiftool.exe")


def extract_polygon(coors, coef_data):
    A, B, D, E, C, F = coef_data
    points = []
    for coor in coors:
        y, x = coor
        x_cor = A * x + B * y + C
        y_cor = D * x + E * y + F
        points.append(QgsPointXY(x_cor, y_cor))
    box_polygon = QgsGeometry.fromPolygonXY([points])
    centroid = box_polygon.centroid()
    return centroid.asPoint().x(), centroid.asPoint().y()


def meter2Degree(latitude, x_length, y_length):
    # convert meter values to degrees
    x_length = x_length / (111320 * math.cos(math.radians(latitude)))
    y_length = y_length / 110540
    return x_length, y_length


def angle_bearing(x_one, y_one, x_two, y_two):
    # calculate azimuth angle
    angle = math.degrees(math.atan2(y_two - y_one, x_two - x_one))
    return (90 - angle) % 360


def distance_pp(pnt_one, pnt_two):
    # distance between two points
    x_start, y_start = pnt_one
    x_end, y_end = pnt_two
    return math.sqrt((x_end - x_start) ** 2 + (y_end - y_start) ** 2)


def delete_tech_layers(list_layers_to_delete):
    # delete layers by names
    for name in list_layers_to_delete:
        if len(QgsProject.instance().mapLayersByName(name)) > 0:
            ds = QgsProject.instance().mapLayersByName(name)[0]
            QgsProject.instance().removeMapLayer(ds.id())
    return


def add_tech_layer(name, type_geometry):
    # add temporary layer
    delete_tech_layers([name])
    iface.mainWindow().blockSignals(True)
    tech_layer = QgsVectorLayer(type_geometry, name, "memory")
    tech_layer.dataProvider().addAttributes([QgsField("type", QVariant.String)])
    tech_layer.dataProvider().addAttributes([QgsField("area", QVariant.Double)])
    tech_layer.setCrs(crs_degrees)
    tech_layer.updateFields()
    iface.mainWindow().blockSignals(False)
    return tech_layer


def img_frame(A, B, D, E, C, F, iw, ih):
    x_one = C
    y_one = F
    x_two = A * iw + B * 0 + x_one
    y_two = D * iw + E * 0 + y_one
    x_three = A * iw + B * ih + x_one
    y_three = D * iw + E * ih + y_one
    x_four = A * 0 + B * ih + x_one
    y_four = D * 0 + E * ih + y_one
    coors = [
        QgsPointXY(x_one, y_one),
        QgsPointXY(x_two, y_two),
        QgsPointXY(x_three, y_three),
        QgsPointXY(x_four, y_four),
        QgsPointXY(x_one, y_one)
    ]
    polygon_geom = QgsGeometry().fromPolygonXY([coors])
    return polygon_geom


def get_corner_points(center_lon, center_lat, altitude, dir_angle, pitch, aspect, sensor_width, focal_length):
    # get corner points of image
    # calculations based on photogrammetry tutorial
    ratXh = sensor_width / focal_length / 2  # ratio of sensor half-width to focal length (at image centre)
    ratYh = aspect * ratXh  # ditto for sensor half-height
    ccf = 1.5 * math.sqrt(1 + (
            ratYh ** 2))  # "corner correction factor" due to sensor crop and fisheye correction. For 0.75 aspect this becomes 1.13, but needs to be calibrated for each camera!
    phiXh, phiYh = math.atan(ratXh), math.atan(
        ratYh)  # 1/2-FOV angle in X,Y directions at image centre. Will be in radians.

    # ground distance of camera ground projection to image; centre, front, back
    Kc = altitude / math.tan(-1 * pitch)
    Kf = altitude / math.tan(-1 * pitch + phiYh)
    Kb = altitude / math.tan(-1 * pitch + phiYh * -1)

    # full distance, hypotenuse of ground distance and altitude triangle
    Rc = math.sqrt(altitude ** 2 + Kc ** 2)
    Rf = math.sqrt(altitude ** 2 + Kf ** 2)
    Rb = math.sqrt(altitude ** 2 + Kb ** 2)

    # 1/2 width of frame in ground coordinates, at centre, front, back; includes ccf fudge factor in corners
    Wch = Rc * ratXh / 1
    Wfh = Rf * ratXh / ccf
    Wbh = Rb * ratXh / ccf

    Centre_W, Centre_K = 0, Kc
    BR_K = BL_K = Kf
    TR_K = TL_K = Kb
    BL_W = BR_W = Wfh
    BR_W = BR_W * -1
    TL_W = TR_W = Wbh
    TR_W = TR_W * -1

    Centre_x = center_lon + (Centre_W) * math.cos(dir_angle) + (Centre_K) * math.sin(dir_angle)
    BR_x = center_lon + (BR_W) * math.cos(dir_angle) + (BR_K) * math.sin(dir_angle)
    BL_x = center_lon + (BL_W) * math.cos(dir_angle) + (BL_K) * math.sin(dir_angle)
    TR_x = center_lon + (TR_W) * math.cos(dir_angle) + (TR_K) * math.sin(dir_angle)
    TL_x = center_lon + (TL_W) * math.cos(dir_angle) + (TL_K) * math.sin(dir_angle)

    Centre_y = center_lat - (Centre_W) * math.sin(dir_angle) + (Centre_K) * math.cos(dir_angle)
    BR_y = center_lat - (BR_W) * math.sin(dir_angle) + (BR_K) * math.cos(dir_angle)
    BL_y = center_lat - (BL_W) * math.sin(dir_angle) + (BL_K) * math.cos(dir_angle)
    TR_y = center_lat - (TR_W) * math.sin(dir_angle) + (TR_K) * math.cos(dir_angle)
    TL_y = center_lat - (TL_W) * math.sin(dir_angle) + (TL_K) * math.cos(dir_angle)

    pntTL = QgsGeometry().fromPointXY(QgsPointXY(TL_x, TL_y))
    pntTR = QgsGeometry().fromPointXY(QgsPointXY(TR_x, TR_y))
    pntBL = QgsGeometry().fromPointXY(QgsPointXY(BL_x, BL_y))
    pntBR = QgsGeometry().fromPointXY(QgsPointXY(BR_x, BR_y))

    pntTL.transform(tr_to_degrees)
    pntTR.transform(tr_to_degrees)
    pntBL.transform(tr_to_degrees)
    pntBR.transform(tr_to_degrees)

    return [pntTL, pntTR, pntBL, pntBR]


def georeference_img(file_in, processed_path, add_points, add_raster):
    # make a georeference for an image
    with open('C:\\Users\\user\\Downloads\\litter_map_1.1\\log.txt', 'w') as f:
        f.write("lol\n")

    file_jgw = os.path.join(os.path.dirname(processed_path), os.path.basename(processed_path).replace('JPG', 'jgw'))

    with open('C:\\Users\\user\\Downloads\\litter_map_1.1\\log.txt', 'a') as f:
        f.write(file_jgw)
        f.write("\n")

    with ExifToolHelper(executable=exiftool_exe) as et:
        with open('C:\\Users\\user\\Downloads\\litter_map_1.1\\log.txt', 'a') as f:
            f.write("here\n")
            f.write(f"len of metadata: {et.get_metadata(file_in)}\n")
            f.flush()
        for d in et.get_metadata(file_in):
            # get image data
            lat = float(d['Composite:GPSLatitude'])
            lon = float(d['Composite:GPSLongitude'])
            altitude_value = float(d['XMP:RelativeAltitude'])
            pitch_value = float(d['XMP:GimbalPitchDegree']) / 180 * math.pi
            dir_spin_value = (90 + float(d['XMP:FlightYawDegree'])) / 180 * math.pi
            dir_init_value = float(d['XMP:FlightYawDegree'])
            focal_length_value = float(d['EXIF:FocalLength']) / 1000
            img_width = int(d['EXIF:ExifImageWidth'])
            img_height = int(d['EXIF:ExifImageHeight'])

            with open('C:\\Users\\user\\Downloads\\litter_map_1.1\\log.txt', 'a') as f:
                f.write(f"w, h: {img_width}, {img_height}\n")

            # calculate auxiliary data
            sensor_width = 2 * (focal_length_value * math.tan((0.5 * float(d['Composite:FOV'])) / 57.296))
            sensor_height = img_height / img_width * sensor_width
            sensor_width_deg, sensor_height_deg = meter2Degree(lat, sensor_width, sensor_height)
            aspect = img_width / img_height
            scale_factor = altitude_value / focal_length_value
            sensor_pixel_width_degrees = sensor_width_deg / img_width
            sensor_pixel_length_degrees = sensor_height_deg / img_height
            img_hwidth_degrees = (sensor_width_deg * scale_factor) / 2
            img_hlength_degrees = (sensor_height_deg * scale_factor) / 2
            ground_pixel_width = sensor_pixel_width_degrees * scale_factor
            ground_pixel_length = sensor_pixel_length_degrees * scale_factor

            # points calculations
            # center point
            pnt_orig = QgsGeometry().fromPointXY(QgsPointXY(lon, lat))
            pnt = QgsGeometry().fromPointXY(QgsPointXY(lon, lat))
            pnt.transform(tr_to_meters)
            lon_m, lat_m = pnt.asPoint().x(), pnt.asPoint().y()

            # get corner points
            pntTL, pntTR, pntBL, pntBR = get_corner_points(
                center_lon=lon_m,
                center_lat=lat_m,
                altitude=altitude_value,
                dir_angle=dir_spin_value,
                pitch=pitch_value,
                aspect=aspect,
                sensor_width=sensor_width,
                focal_length=focal_length_value
            )

            # get corners' x and y
            x_tl, y_tl = pntTL.asPoint().x(), pntTL.asPoint().y()
            x_tr, y_tr = pntTR.asPoint().x(), pntTR.asPoint().y()
            x_bl, y_bl = pntBL.asPoint().x(), pntBL.asPoint().y()
            x_br, y_br = pntBR.asPoint().x(), pntBR.asPoint().y()

            # calcuilate ABDE coefficients
            A = math.cos(math.radians(dir_init_value)) * ground_pixel_width
            B = -(math.sin(math.radians(dir_init_value)) * ground_pixel_length)
            D = -(math.sin(math.radians(dir_init_value)) * ground_pixel_width)
            E = -(math.cos(math.radians(dir_init_value)) * ground_pixel_length)

            C, F = x_br, y_br

            # write world file
            with open(file_jgw, 'w') as f:
                f.write(f"{A:1.10f}\n")  # A
                f.write(f"{B:1.10f}\n")  # D
                f.write(f"{D:1.10f}\n")  #
                f.write(f"{E:1.10f}\n")
                f.write(f"{x_br}\n")
                f.write(f"{y_br}")

            with open('C:\\Users\\user\\Downloads\\litter_map_1.1\\log.txt', 'a') as f:
                f.write("jgw\n")
                f.write(f"{x_br}, {y_br}, {ground_pixel_width}, {ground_pixel_length}")
                f.flush()

            if add_raster:
                r_layer = QgsRasterLayer(processed_path, os.path.basename(processed_path))
                r_layer.setCrs(crs_degrees)
                QgsProject.instance().addMapLayer(r_layer)
                provider = r_layer.dataProvider()
                provider.setNoDataValue(1, 0)  # remove black value
                r_layer.triggerRepaint()
                l_id = QgsProject.instance().layerTreeRoot().findLayer(r_layer.id())
                # l_id.setItemVisibilityChecked(False)
                l_id.setExpanded(False)
            if add_points:
                new_layer = add_tech_layer("PNTS", 'Point')
                for g in [pnt_orig, pntTL, pntTR, pntBL, pntBR]:
                    r_feature = QgsFeature()
                    r_feature.setFields(new_layer.fields())
                    r_feature.setGeometry(g)
                    new_layer.dataProvider().addFeatures([r_feature])
                QgsProject.instance().addMapLayer(new_layer)
                # print(A, D, B, E, C, F, img_width, img_height)
            return A, D, B, E, C, F, img_width, img_height


class LitterMapDialog(QWidget):
    def __init__(self, parent=None):
        # set interface and variables
        super().__init__(parent)

        # variables
        self.attempt = 1
        self.current_xy = []
        self.point_tool = None
        self.dct_img = {}
        self.stat_data = []

        # mainframe settings
        # self.setWindowFlags(self.windowFlags() | QtCore.Qt.WindowStaysOnTopHint)
        self.setWindowTitle('LitterMap')
        self.setGeometry(800, 650, 350, 0)

        self.btn_load_images = QPushButton("Загрузить изображения")

        self.txt_area = QTextEdit(self)
        self.txt_area.setReadOnly(True)
        # self.btn_save_stat = QPushButton("Сохранить статистику")
        self.prog_bar = QProgressBar(self)

        self.grid_layout = QGridLayout(self)
        self.grid_layout.setSpacing(10)
        self.setLayout(self.grid_layout)

        self.grid_layout.addWidget(self.btn_load_images, 0, 1, 1, 3)
        self.grid_layout.addWidget(self.txt_area, 1, 1, 1, 3)
        # self.grid_layout.addWidget(self.btn_save_stat, 2, 1, 1, 3)
        self.grid_layout.addWidget(self.prog_bar, 2, 1, 1, 3)

        self.btn_load_images.clicked.connect(self.load_images)
        # self.btn_save_stat.clicked.connect(self.save_stat)
        # self.btn_save_stat.setDisabled(True)

        self.show()

    def save_stat(self):
        out_file = QFileDialog.getSaveFileName(None, "Сохранить статистику", "", "CSV (*.csv)")
        if out_file[0]:
            with open(out_file[0], mode='w', encoding='cp1251', newline='') as stat_file:
                stat_writer = csv.writer(stat_file, delimiter=';')
                for row in self.stat_data:
                    row_corrected = [row[0], '="{}"'.format(row[1]), '="{}"'.format(row[2])]
                    stat_writer.writerow(row_corrected)
            self.warning_message('Статистика записана в файл {}'.format(out_file[0]))

    def warning_message(self, err_text):
        # message box

        msg = QMessageBox()
        msg.warning(self, "Уведомление", err_text)
        return

    def process_image(self, image_path, processed_dir_path):
        url = "https://node-api.datasphere.yandexcloud.net/process"
        headers = {
            "x-node-alias": "datasphere.user.segmentation-backend",
            "Authorization": "Api-Key AQVN1vLuEmspghqfLIBxf2nmNDzctez-kjrrxKdx",
            "x-folder-id": "b1gbm9skjpv4gt0r8dmi",
        }
        response = requests.post(url, headers=headers, files={"image": open(image_path, 'rb')})
        processed_path = ""
        cl_coefs = {}
        if response.status_code == 400:
            print(response.text)
        else:
            base_name = os.path.basename(image_path)
            processed_path = os.path.join(processed_dir_path, base_name)
            save_file = open(processed_path, "wb")
            save_file.write(response.content)
            save_file.close()

            cl_coefs_str = response.cookies.get("cl_coefs").replace("\\054", ",")[1:-1]
            cl_coefs = ast.literal_eval(cl_coefs_str)
        return processed_path, cl_coefs

    def load_images(self):
        images = QFileDialog.getOpenFileNames(self, 'Загрузить изображения', None, "Image files (*.jpg)")[0]
        if not images:
            return
        step = 100. / len(images)
        step_count = 0
        new_layer_polygon = add_tech_layer("Frames", 'Multipolygon')

        stat_litter_count = 0
        stat_litter_area = 0
        stat_litter_volume = 0
        stat_litter_mass = 0
        # x_length = 0
        # y_length = 0

        cl_to_name = {
            1: "железо",
            2: "рыболовные снасти",
            3: "пластик",
            4: "дерево",
            5: "бетон",
            6: "резина"
        }
        name_to_cl = {
            y: x for x, y in cl_to_name.items()
        }
        stat_litter_classes = {}
        for _, name in cl_to_name.items():
            stat_litter_classes[name] = {
                'cnt': 0,
                'area': 0.0,
                'volume': 0.0,
                'mass': 0.0
            }

        all_frame = None
        frame_intersection = None

        pic_coors = add_tech_layer('NN_points', 'Point')
        # pic_coors_heatmap = add_tech_layer('NN_points_heatmap', 'Point')

        dirpath = os.path.dirname(os.path.abspath(images[0]))
        processed_dir = dirpath + "/processed"
        try:
            os.makedirs(processed_dir)
        except:
            pass

        for file_in in images:
            processed_path, cl_to_coefs = self.process_image(file_in, processed_dir_path=processed_dir)

            A, B, D, E, C, F, iw, ih = georeference_img(file_in, processed_path, True, True)
            polygon_coors = img_frame(A, B, D, E, C, F, iw, ih)

            r_feature = QgsFeature()
            r_feature.setFields(new_layer_polygon.fields())
            r_feature.setGeometry(polygon_coors)
            new_layer_polygon.dataProvider().addFeatures([r_feature])

            # self.dct_img[f_name.replace('.JPG', '')] = [A, B, D, E, C, F, iw, ih]
            polygon_coors_m = img_frame(A, B, D, E, C, F, iw, ih)
            polygon_coors_m.transform(tr_to_meters)

            # if not x_length:
            #     flat_polygon = img_frame(A, 0, 0, E, C, F, 1, 1)
            #     flat_polygon.transform(tr_to_meters)
            #     x_length = round(flat_polygon.boundingBox().width(), 2) * 100
            #     y_length = round(flat_polygon.boundingBox().height(), 2) * 100

            area_polygon = polygon_coors_m.area()

            if all_frame:
                frame_intersection = all_frame.intersection(polygon_coors)

            for cl, type_pnt in cl_to_name.items():
                points = cl_to_coefs[cl]

                for point in points:
                    y, x, area, volume_coef, mass_coef = point
                    if area <= 0:
                        continue
                    # может быть нужно поменять x и у местами
                    x_cor = A * x + B * y + C
                    y_cor = D * x + E * y + F

                    # centroid = polygon_coors.centroid()
                    # x_cor, y_cor = centroid.asPoint().x(), centroid.asPoint().y()

                    area = round(area_polygon * area / (iw * ih), 3)
                    pnt = QgsGeometry().fromPointXY(QgsPointXY(x_cor, y_cor))
                    if frame_intersection:
                        if pnt.intersects(all_frame):
                            continue
                    r_feature = QgsFeature()
                    r_feature.setFields(pic_coors.fields())
                    r_feature["type"] = type_pnt
                    r_feature["area"] = area
                    stat_litter_area += area
                    stat_litter_classes[type_pnt]['area'] += area

                    volume = area * volume_coef
                    mass = area * mass_coef

                    stat_litter_classes[type_pnt]['cnt'] += 1
                    stat_litter_classes[type_pnt]['volume'] += volume
                    stat_litter_classes[type_pnt]['mass'] += mass

                    stat_litter_volume += volume
                    stat_litter_mass += mass
                    stat_litter_count += 1

                    r_feature.setGeometry(pnt)
                    pic_coors.dataProvider().addFeatures([r_feature])
                    # pic_coors_heatmap.dataProvider().addFeatures([r_feature])
            if not all_frame:
                all_frame = polygon_coors
            else:
                all_frame = all_frame.combine(polygon_coors)

            step_count += step
            self.prog_bar.setValue(step_count)
            QtCore.QCoreApplication.processEvents()

        for t in stat_litter_classes:
            stat_litter_classes[t]['area'] = round(stat_litter_classes[t]['area'], 2)
            stat_litter_classes[t]['volume'] = round(stat_litter_classes[t]['volume'], 2)
            stat_litter_classes[t]['mass'] = round(stat_litter_classes[t]['mass'], 2)

        stat_litter_area = round(stat_litter_area, 2)
        stat_litter_volume = round(stat_litter_volume, 2)
        stat_litter_mass = round(stat_litter_mass, 2)

        centroid_polygon = all_frame.centroid().asPoint()
        c_x, c_y = round(centroid_polygon.x(), 5), round(centroid_polygon.y(), 5)
        all_frame.transform(tr_to_meters)

        stat_msg = ""

        for cl, name in cl_to_name.items():
            if name in stat_litter_classes:
                stat_msg += f"{name}: количество - {stat_litter_classes[name]['cnt']},  площадь - {stat_litter_classes[name]['area']} кв.м., объём - {stat_litter_classes[name]['volume']} куб.м., масса - {stat_litter_classes[name]['mass']} кг\n"

        stat_msg += f"fСуммарно: количество: {stat_litter_count}, площадь: {stat_litter_area}, объём: {stat_litter_volume}, масса: {stat_litter_mass}\n"
        stat_msg += f"Центроид участка - ({c_x}, {c_y})\n"
        self.txt_area.setPlainText(stat_msg)

        # self.stat_data = [
        #     ['Тип мусора', 'Количество, ед.', 'Площадь, кв.м.']
        # ]
        # for cl in cl_to_name.keys():
        #
        # self.stat_data = [
        #     ['Тип мусора', 'Количество, ед.', 'Площадь, кв.м.'],
        #     ['железо', stat_litter_classes['железо']['num'], stat_litter_classes['железо']['area']],
        #     ['рыболовные снасти', stat_litter_classes['рыболовные снасти']['num'],
        #      stat_litter_classes['рыболовные снасти']['area']],
        #     ['пластик', stat_litter_classes['пластик']['num'], stat_litter_classes['пластик']['area']],
        #     ['дерево', stat_litter_classes['дерево']['num'], stat_litter_classes['дерево']['area']],
        #     ['бетон', stat_litter_classes['бетон']['num'], stat_litter_classes['бетон']['area']],
        #     ['резина', stat_litter_classes['резина']['num'], stat_litter_classes['резина']['area']],
        #     ['Итого', '', ''],
        #     ["Общее количество мусора, ед.", stat_litter_count, ''],
        #     ["Общая площадь мусора, кв. м.", stat_litter_area, ''],
        #     ["Общая площадь участка, кв. м.", round(all_frame.area(), 2), ''],
        #     ["Центроид участка", '({}, {})'.format(c_x, c_y), ''],
        #     ["Пространственное разрешение, см", '{} x {}'.format(x_length, y_length), '']
        # ]

        QgsProject.instance().addMapLayer(pic_coors)
        # QgsProject.instance().addMapLayer(pic_coors_heatmap)
        pic_coors.loadNamedStyle(classes_style)
        # pic_coors_heatmap.loadNamedStyle(heatmap_style)
        # self.btn_save_stat.setDisabled(False)
        self.prog_bar.setValue(0)

# app = LitterMapDialog()
